import 'dotenv/config';
import bcrypt from 'bcryptjs';
import {
  PrismaClient,
  PropertyStatus,
  UserRole,
  VendorStatus,
  type Property,
  HoldStatus,
  BookingStatus,
  PaymentProvider,
  PaymentStatus,
  OpsTaskStatus,
  OpsTaskType,
  ServicePlanType,
  VendorAgreementStatus,
} from '@prisma/client';

const prisma = new PrismaClient();

function slugify(input: string) {
  return input
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-');
}

async function main() {
  if (!process.env.DATABASE_URL) {
    throw new Error('DATABASE_URL is missing. Put it in apps/api/.env');
  }

  const passwordHash = await bcrypt.hash('Password123!', 10);

  // -----------------------------
  // CLEAN (order matters due to relations)
  // -----------------------------

  // Operator layer: deepest first
  await prisma.workOrder.deleteMany().catch(() => undefined);
  await prisma.maintenanceRequest.deleteMany().catch(() => undefined);
  await prisma.opsTask.deleteMany().catch(() => undefined);
  await prisma.propertyServiceConfig.deleteMany().catch(() => undefined);
  await prisma.vendorServiceAgreement.deleteMany().catch(() => undefined);
  await prisma.servicePlan.deleteMany().catch(() => undefined);

  // Payments/Cancellation/Booking
  await prisma.paymentEvent.deleteMany().catch(() => undefined);
  await prisma.refund.deleteMany().catch(() => undefined);
  await prisma.payment.deleteMany().catch(() => undefined);

  await prisma.bookingCancellation.deleteMany().catch(() => undefined);
  await prisma.cancellationPolicyConfig.deleteMany().catch(() => undefined);

  await prisma.bookingIdempotency.deleteMany().catch(() => undefined);
  await prisma.booking.deleteMany().catch(() => undefined);

  // Availability
  await prisma.propertyHold.deleteMany().catch(() => undefined);
  await prisma.propertyCalendarDay.deleteMany().catch(() => undefined);
  await prisma.propertyAvailabilitySettings.deleteMany().catch(() => undefined);

  // Listing
  await prisma.media.deleteMany().catch(() => undefined);

  // ✅ Amenities (delete join table first, then Amenity, then AmenityGroup)
  await prisma.propertyAmenity.deleteMany().catch(() => undefined);
  await prisma.amenity.deleteMany().catch(() => undefined);
  await prisma.amenityGroup.deleteMany().catch(() => undefined);

  await prisma.location.deleteMany().catch(() => undefined);

  await prisma.property.deleteMany().catch(() => undefined);
  await prisma.vendorProfile.deleteMany().catch(() => undefined);
  await prisma.user.deleteMany().catch(() => undefined);

  // -----------------------------
  // USERS
  // -----------------------------

  // Admin
  const admin = await prisma.user.create({
    data: { email: 'admin@demo.com', passwordHash, role: UserRole.ADMIN },
  });

  // Vendors
  const vendor1 = await prisma.user.create({
    data: { email: 'vendor1@demo.com', passwordHash, role: UserRole.VENDOR },
  });
  const vendor2 = await prisma.user.create({
    data: { email: 'vendor2@demo.com', passwordHash, role: UserRole.VENDOR },
  });

  // Vendor Profiles
  const vp1 = await prisma.vendorProfile.create({
    data: {
      userId: vendor1.id,
      displayName: 'Vendor One',
      companyName: 'Vendor One Stays',
      phone: '+92 300 0000001',
      status: VendorStatus.APPROVED,
    },
  });

  const vp2 = await prisma.vendorProfile.create({
    data: {
      userId: vendor2.id,
      displayName: 'Vendor Two',
      companyName: 'Vendor Two Homes',
      phone: '+92 300 0000002',
      status: VendorStatus.APPROVED,
    },
  });

  // Customers
  const customers = await Promise.all(
    Array.from({ length: 5 }).map((_, i) =>
      prisma.user.create({
        data: {
          email: `customer${i + 1}@demo.com`,
          passwordHash,
          role: UserRole.CUSTOMER,
        },
      }),
    ),
  );

  // -----------------------------
  // ✅ AMENITIES (Frank Porter detail-page ready)
  // -----------------------------

  const amenityGroups = [
    { key: 'ESSENTIALS', name: 'Essentials', sortOrder: 10 },
    { key: 'KITCHEN', name: 'Kitchen', sortOrder: 20 },
    { key: 'BATHROOM', name: 'Bathroom', sortOrder: 30 },
    { key: 'BEDROOM_LAUNDRY', name: 'Bedroom & Laundry', sortOrder: 40 },
    { key: 'HEATING_COOLING', name: 'Heating & Cooling', sortOrder: 50 },
    { key: 'ENTERTAINMENT', name: 'Entertainment', sortOrder: 60 },
    { key: 'FAMILY', name: 'Family', sortOrder: 70 },
    { key: 'BUILDING', name: 'Building', sortOrder: 80 },
    { key: 'OUTDOOR', name: 'Outdoor', sortOrder: 90 },
    { key: 'SAFETY', name: 'Safety', sortOrder: 100 },
    { key: 'ACCESSIBILITY', name: 'Accessibility', sortOrder: 110 },
  ] as const;

  for (const g of amenityGroups) {
    await prisma.amenityGroup.upsert({
      where: { key: g.key },
      create: {
        key: g.key,
        name: g.name,
        sortOrder: g.sortOrder,
        isActive: true,
      },
      update: {
        name: g.name,
        sortOrder: g.sortOrder,
        isActive: true,
      },
    });
  }

  const groups = await prisma.amenityGroup.findMany({ where: { isActive: true } });
  const groupByKey = new Map(groups.map((g) => [g.key, g]));

  function groupId(key: (typeof amenityGroups)[number]['key']) {
    const g = groupByKey.get(key);
    if (!g) throw new Error(`AmenityGroup ${key} not found`);
    return g.id;
  }

  const amenities = [
    // Essentials
    { key: 'WIFI', name: 'Wi-Fi', groupKey: 'ESSENTIALS', sortOrder: 10 },
    { key: 'TOWELS', name: 'Towels', groupKey: 'ESSENTIALS', sortOrder: 20 },
    { key: 'BED_LINENS', name: 'Bed linens', groupKey: 'ESSENTIALS', sortOrder: 30 },
    { key: 'SHAMPOO', name: 'Shampoo', groupKey: 'ESSENTIALS', sortOrder: 40 },
    { key: 'BASIC_TOILETRIES', name: 'Basic toiletries', groupKey: 'ESSENTIALS', sortOrder: 50 },
    { key: 'TV', name: 'TV', groupKey: 'ENTERTAINMENT', sortOrder: 10 },

    // Kitchen
    { key: 'KITCHEN', name: 'Kitchen', groupKey: 'KITCHEN', sortOrder: 10 },
    { key: 'REFRIGERATOR', name: 'Refrigerator', groupKey: 'KITCHEN', sortOrder: 20 },
    { key: 'MICROWAVE', name: 'Microwave', groupKey: 'KITCHEN', sortOrder: 30 },
    { key: 'OVEN', name: 'Oven', groupKey: 'KITCHEN', sortOrder: 40 },
    { key: 'STOVE', name: 'Stove', groupKey: 'KITCHEN', sortOrder: 50 },
    { key: 'KETTLE', name: 'Kettle', groupKey: 'KITCHEN', sortOrder: 60 },
    { key: 'COFFEE_MAKER', name: 'Coffee maker', groupKey: 'KITCHEN', sortOrder: 70 },
    { key: 'DISHES_CUTLERY', name: 'Dishes & cutlery', groupKey: 'KITCHEN', sortOrder: 80 },

    // Bathroom
    { key: 'HOT_WATER', name: 'Hot water', groupKey: 'BATHROOM', sortOrder: 10 },
    { key: 'HAIR_DRYER', name: 'Hair dryer', groupKey: 'BATHROOM', sortOrder: 20 },

    // Bedroom & Laundry
    { key: 'HANGERS', name: 'Hangers', groupKey: 'BEDROOM_LAUNDRY', sortOrder: 10 },
    { key: 'IRON', name: 'Iron', groupKey: 'BEDROOM_LAUNDRY', sortOrder: 20 },
    { key: 'WASHING_MACHINE', name: 'Washing machine', groupKey: 'BEDROOM_LAUNDRY', sortOrder: 30 },

    // Heating & Cooling
    { key: 'AIR_CONDITIONING', name: 'Air conditioning', groupKey: 'HEATING_COOLING', sortOrder: 10 },
    { key: 'HEATING', name: 'Heating', groupKey: 'HEATING_COOLING', sortOrder: 20 },

    // Entertainment
    { key: 'NETFLIX', name: 'Netflix', groupKey: 'ENTERTAINMENT', sortOrder: 20 },

    // Family
    { key: 'BABY_COT', name: 'Baby cot / crib', groupKey: 'FAMILY', sortOrder: 10 },
    { key: 'HIGH_CHAIR', name: 'High chair', groupKey: 'FAMILY', sortOrder: 20 },

    // Building
    { key: 'ELEVATOR', name: 'Elevator', groupKey: 'BUILDING', sortOrder: 10 },
    { key: 'GYM', name: 'Gym', groupKey: 'BUILDING', sortOrder: 20 },
    { key: 'POOL', name: 'Pool', groupKey: 'BUILDING', sortOrder: 30 },
    { key: 'PARKING', name: 'Free parking', groupKey: 'BUILDING', sortOrder: 40 },
    { key: 'DOORMAN', name: 'Doorman', groupKey: 'BUILDING', sortOrder: 50 },

    // Outdoor
    { key: 'BALCONY', name: 'Balcony', groupKey: 'OUTDOOR', sortOrder: 10 },

    // Safety
    { key: 'SMOKE_ALARM', name: 'Smoke alarm', groupKey: 'SAFETY', sortOrder: 10 },
    { key: 'CARBON_MONOXIDE_ALARM', name: 'Carbon monoxide alarm', groupKey: 'SAFETY', sortOrder: 20 },
    { key: 'FIRE_EXTINGUISHER', name: 'Fire extinguisher', groupKey: 'SAFETY', sortOrder: 30 },
    { key: 'FIRST_AID_KIT', name: 'First aid kit', groupKey: 'SAFETY', sortOrder: 40 },

    // Accessibility
    { key: 'STEP_FREE_ACCESS', name: 'Step-free access', groupKey: 'ACCESSIBILITY', sortOrder: 10 },
  ] as const;

  for (const a of amenities) {
    await prisma.amenity.upsert({
      where: { key: a.key },
      create: {
        key: a.key,
        name: a.name,
        icon: null,
        groupId: groupId(a.groupKey),
        sortOrder: a.sortOrder,
        isActive: true,
      },
      update: {
        name: a.name,
        groupId: groupId(a.groupKey),
        sortOrder: a.sortOrder,
        isActive: true,
      },
    });
  }

  // ✅ Backfill: any amenity without a group goes to Essentials (safe default)
  await prisma.amenity.updateMany({
    where: { groupId: null },
    data: { groupId: groupId('ESSENTIALS') },
  });

  const allAmenityKeys = await prisma.amenity.findMany({
    select: { key: true },
  });
  const amenityKeysSet = new Set(allAmenityKeys.map((x) => x.key));

  // -----------------------------
  // OPERATOR: SERVICE PLANS (Frank Porter style)
  // -----------------------------

  const plans = [
    {
      code: 'FP_LIST',
      type: ServicePlanType.LISTING_ONLY,
      name: 'Listing Only',
      description: 'We only list and manage bookings. Owner handles operations.',
      managementFeeBps: 0,
      includesCleaning: false,
      includesLinen: false,
      includesInspection: false,
      includesRestock: false,
      includesMaintenance: false,
      isActive: true,
    },
    {
      code: 'FP_SEMI',
      type: ServicePlanType.SEMI_MANAGED,
      name: 'Semi-Managed',
      description: 'Bookings + core ops. Some responsibilities remain with owner.',
      managementFeeBps: 1500,
      includesCleaning: true,
      includesLinen: true,
      includesInspection: true,
      includesRestock: false,
      includesMaintenance: true,
      isActive: true,
    },
    {
      code: 'FP_FULL',
      type: ServicePlanType.FULLY_MANAGED,
      name: 'Fully Managed',
      description:
        'Full managed program: bookings + operations + maintenance coordination.',
      managementFeeBps: 1900,
      includesCleaning: true,
      includesLinen: true,
      includesInspection: true,
      includesRestock: true,
      includesMaintenance: true,
      isActive: true,
    },
  ] as const;

  for (const p of plans) {
    await prisma.servicePlan.upsert({
      where: { code: p.code },
      create: p,
      update: { ...p },
    });
  }

  const fullPlan = await prisma.servicePlan.findUnique({
    where: { code: 'FP_FULL' },
  });
  if (!fullPlan) throw new Error('FP_FULL plan not found after seeding.');

  // -----------------------------
  // OPERATOR: VENDOR AGREEMENTS
  // -----------------------------

  const now = new Date();

  const ag1 = await prisma.vendorServiceAgreement.create({
    data: {
      vendorProfileId: vp1.id,
      servicePlanId: fullPlan.id,
      status: VendorAgreementStatus.ACTIVE,
      startDate: now,
      endDate: null,
      agreedManagementFeeBps: fullPlan.managementFeeBps,
      notes: 'Seed agreement (Fully Managed).',
      approvedByAdminId: admin.id,
      approvedAt: now,
    },
  });

  const ag2 = await prisma.vendorServiceAgreement.create({
    data: {
      vendorProfileId: vp2.id,
      servicePlanId: fullPlan.id,
      status: VendorAgreementStatus.ACTIVE,
      startDate: now,
      endDate: null,
      agreedManagementFeeBps: fullPlan.managementFeeBps,
      notes: 'Seed agreement (Fully Managed).',
      approvedByAdminId: admin.id,
      approvedAt: now,
    },
  });

  // -----------------------------
  // PROPERTIES
  // -----------------------------

  const sampleProps = [
    { title: 'Luxury Downtown Apartment', city: 'Dubai', area: 'Downtown', price: 45000 },
    { title: 'Marina View Studio', city: 'Dubai', area: 'Dubai Marina', price: 32000 },
    { title: 'Palm Jumeirah Resort Suite', city: 'Dubai', area: 'Palm Jumeirah', price: 90000 },
    { title: 'Modern Business Bay Flat', city: 'Dubai', area: 'Business Bay', price: 38000 },
    { title: 'Cozy JLT Apartment', city: 'Dubai', area: 'JLT', price: 28000 },
    { title: 'City Walk Premium Stay', city: 'Dubai', area: 'City Walk', price: 52000 },
    { title: 'Creek Harbour Escape', city: 'Dubai', area: 'Creek Harbour', price: 41000 },
    { title: 'Minimalist Al Barsha Home', city: 'Dubai', area: 'Al Barsha', price: 25000 },
  ];

  const vendors = [
    { user: vendor1, agreement: ag1 },
    { user: vendor2, agreement: ag2 },
  ];

  const properties: Property[] = [];

  // helper: select a consistent amenity subset per property
  const amenitySets = [
    ['WIFI', 'AIR_CONDITIONING', 'TV', 'KITCHEN', 'REFRIGERATOR', 'MICROWAVE', 'ELEVATOR', 'POOL', 'GYM'],
    ['WIFI', 'AIR_CONDITIONING', 'TV', 'KITCHEN', 'REFRIGERATOR', 'PARKING', 'BALCONY'],
    ['WIFI', 'AIR_CONDITIONING', 'TV', 'KITCHEN', 'OVEN', 'COFFEE_MAKER', 'POOL', 'DOORMAN'],
    ['WIFI', 'AIR_CONDITIONING', 'TV', 'KITCHEN', 'REFRIGERATOR', 'ELEVATOR', 'PARKING'],
  ] as const;

  for (let i = 0; i < sampleProps.length; i++) {
    const v = vendors[i % vendors.length];
    const p = sampleProps[i];
    const slug = `${slugify(p.title)}-${i + 1}`;

    const created = await prisma.property.create({
      data: {
        vendorId: v.user.id,
        title: p.title,
        slug,
        description: 'Seed listing for development. Replace content later.',
        city: p.city,
        area: p.area,
        maxGuests: 2 + (i % 4),
        bedrooms: 1 + (i % 3),
        bathrooms: 1 + (i % 2),
        basePrice: p.price,
        cleaningFee: 5000,
        currency: 'PKR',
        status: PropertyStatus.PUBLISHED,
        media: {
          createMany: {
            data: [
              { url: 'https://picsum.photos/seed/1/1200/800', alt: 'Cover', sortOrder: 0 },
              { url: 'https://picsum.photos/seed/2/1200/800', alt: 'Living', sortOrder: 1 },
              { url: 'https://picsum.photos/seed/3/1200/800', alt: 'Bedroom', sortOrder: 2 },
            ],
          },
        },
      },
    });

    properties.push(created);

    // ✅ Attach amenities (grouped, UI-ready)
    const chosen = amenitySets[i % amenitySets.length].filter((k) => amenityKeysSet.has(k));
    const amenityRows = await prisma.amenity.findMany({
      where: { key: { in: chosen } },
      select: { id: true },
    });

    if (amenityRows.length > 0) {
      await prisma.propertyAmenity.createMany({
        data: amenityRows.map((a) => ({ propertyId: created.id, amenityId: a.id })),
        skipDuplicates: true,
      });
    }

    // ✅ PropertyServiceConfig
    // IMPORTANT: set overrides to NULL so plan defaults drive behavior (FP logic).
    await prisma.propertyServiceConfig.create({
      data: {
        propertyId: created.id,
        servicePlanId: fullPlan.id,
        vendorAgreementId: v.agreement.id,

        cleaningRequired: null,
        linenChangeRequired: null,
        inspectionRequired: null,
        restockRequired: null,
        maintenanceIncluded: null,

        guestCleaningFee: null,
        linenFee: null,
        inspectionFee: null,
        restockFee: null,

        currency: 'PKR',
      },
    });
  }

  // -----------------------------
  // BOOKINGS (requires holds)
  // First 3 => CONFIRMED + CAPTURED + OpsTasks created (verify operator layer)
  // Next 3 => PENDING_PAYMENT normal flow
  // -----------------------------

  const day = 24 * 60 * 60 * 1000;

  for (let i = 0; i < 6; i++) {
    const customer = customers[i % customers.length];
    const property = properties[i % properties.length];

    const checkIn = new Date(now.getTime() + (i + 2) * day);
    const checkOut = new Date(now.getTime() + (i + 5) * day);

    const nights = Math.max(
      1,
      Math.round((checkOut.getTime() - checkIn.getTime()) / day),
    );
    const totalAmount = property.basePrice * nights + property.cleaningFee;

    // 1) Hold
    const hold = await prisma.propertyHold.create({
      data: {
        propertyId: property.id,
        checkIn,
        checkOut,
        status: HoldStatus.ACTIVE,
        expiresAt: new Date(now.getTime() + 60 * 60 * 1000),
        createdById: customer.id,
      },
    });

    const shouldConfirm = i < 3;

    // 2) Booking + Payment
    const booking = await prisma.booking.create({
      data: {
        customerId: customer.id,
        propertyId: property.id,
        holdId: hold.id,
        checkIn,
        checkOut,
        adults: 2,
        children: i % 2,

        status: shouldConfirm
          ? BookingStatus.CONFIRMED
          : BookingStatus.PENDING_PAYMENT,

        totalAmount,
        currency: 'PKR',

        payment: {
          create: {
            provider: PaymentProvider.MANUAL,
            status: shouldConfirm
              ? PaymentStatus.CAPTURED
              : PaymentStatus.REQUIRES_ACTION,
            amount: totalAmount,
            currency: 'PKR',
            providerRef: `seed_${i + 1}`,
          },
        },
      },
    });

    // 3) Convert hold
    await prisma.propertyHold.update({
      where: { id: hold.id },
      data: {
        status: HoldStatus.CONVERTED,
        convertedAt: new Date(),
        bookingId: booking.id,
      },
    });

    // 4) Operator: create OpsTasks for confirmed bookings
    if (shouldConfirm) {
      const types: OpsTaskType[] = [
        OpsTaskType.CLEANING,
        OpsTaskType.INSPECTION,
        OpsTaskType.LINEN,
        OpsTaskType.RESTOCK,
      ];

      for (const type of types) {
        await prisma.opsTask.upsert({
          where: {
            bookingId_type: {
              bookingId: booking.id,
              type,
            },
          },
          create: {
            bookingId: booking.id,
            propertyId: property.id,
            type,
            status: OpsTaskStatus.PENDING,
            scheduledFor: checkOut, // checkout-day ops (FP style)
          },
          update: {
            // If already exists, keep status and assignment intact; only ensure schedule/property consistency
            propertyId: property.id,
            scheduledFor: checkOut,
          },
        });
      }
    }
  }

  // eslint-disable-next-line no-console
  console.log('✅ Seed complete');
  // eslint-disable-next-line no-console
  console.log({
    admin: admin.email,
    vendors: [vendor1.email, vendor2.email],
    customers: customers.map((c) => c.email),
    properties: properties.map((p) => p.slug),
  });
}

main()
  .catch((e) => {
    // eslint-disable-next-line no-console
    console.error('❌ Seed failed:', e);
    process.exitCode = 1;
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
