generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  CUSTOMER
  VENDOR
  ADMIN
}

enum VendorStatus {
  PENDING
  APPROVED
  REJECTED
}

/**
 * âœ… Property lifecycle now includes review/moderation workflow
 * - Vendor can edit in DRAFT or CHANGES_REQUESTED
 * - Vendor submits => UNDER_REVIEW
 * - Admin approves => APPROVED (vendor can publish)
 * - Admin rejects => REJECTED
 * - PUBLISHED = live
 * - SUSPENDED = admin takedown
 */
enum PropertyStatus {
  DRAFT
  UNDER_REVIEW
  APPROVED
  CHANGES_REQUESTED
  REJECTED
  PUBLISHED
  SUSPENDED
  ARCHIVED
}

enum BookingStatus {
  PENDING_PAYMENT
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum PaymentProvider {
  STRIPE
  TELR
  MANUAL
  OTHER
}

enum PaymentStatus {
  REQUIRES_ACTION
  AUTHORIZED
  CAPTURED
  FAILED
  REFUNDED
}

enum CalendarDayStatus {
  AVAILABLE
  BLOCKED
}

enum HoldStatus {
  ACTIVE
  EXPIRED
  CONVERTED
  CANCELLED
}

enum CancellationActor {
  CUSTOMER
  VENDOR
  ADMIN
}

enum CancellationReason {
  GUEST_REQUEST
  OWNER_REQUEST
  NO_PAYMENT
  FORCE_MAJEURE
  FRAUD
  ADMIN_OVERRIDE
}

enum CancellationMode {
  SOFT
  HARD
}

enum RefundStatus {
  PENDING
  PROCESSING
  SUCCEEDED
  FAILED
  CANCELLED
}

enum RefundReason {
  CANCELLATION
  PARTIAL_ADJUSTMENT
  GOODWILL
  DISPUTE
}

enum SecurityDepositStatus {
  NOT_REQUIRED
  REQUIRED
  AUTHORIZED
  CAPTURED
  RELEASED
  CLAIMED
  FAILED
  CANCELLED
}

enum SecurityDepositMode {
  NONE
  AUTHORIZE
  CAPTURE
}

enum VendorStatementStatus {
  DRAFT
  FINALIZED
  PAID
  VOID
}

enum PayoutStatus {
  PENDING
  PROCESSING
  SUCCEEDED
  FAILED
  CANCELLED
}

enum LedgerEntryType {
  BOOKING_CAPTURED
  MANAGEMENT_FEE
  REFUND
  DEPOSIT_AUTH
  DEPOSIT_CAPTURE
  DEPOSIT_RELEASE
  DEPOSIT_CLAIM
  ADJUSTMENT
  PAYOUT
}

enum LedgerDirection {
  CREDIT
  DEBIT
}

enum PenaltyType {
  NONE
  PERCENT_OF_NIGHTS
  PERCENT_OF_TOTAL
  FIXED_FEE
}

enum PaymentEventType {
  AUTHORIZE
  CAPTURE
  REFUND
  WEBHOOK
}

//
// ðŸ”” Notifications Layer (V1) enums
//

enum NotificationType {
  EMAIL_VERIFICATION_OTP
  BOOKING_CONFIRMED
  BOOKING_CANCELLED
  PAYMENT_FAILED
  SMTP_TEST
  REFUND_PROCESSED
  NEW_BOOKING_RECEIVED
  BOOKING_CANCELLED_BY_GUEST
  OPS_TASKS_CREATED
  MAINTENANCE_REQUEST_CREATED
}

enum NotificationChannel {
  EMAIL
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
}

//
// âœ… Operator Services Layer (V1) enums
//

enum ServicePlanType {
  LISTING_ONLY
  SEMI_MANAGED
  FULLY_MANAGED
}

enum VendorAgreementStatus {
  ACTIVE
  PAUSED
  TERMINATED
}

enum OpsTaskType {
  CLEANING
  INSPECTION
  LINEN
  RESTOCK
}

enum OpsTaskStatus {
  PENDING
  ASSIGNED
  IN_PROGRESS
  DONE
  CANCELLED
}

enum MaintenancePriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum MaintenanceStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CANCELLED
}

enum WorkOrderStatus {
  DRAFT
  APPROVED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

//
// âœ… Listing verification (V1) enums
//

/**
 * âœ… Expanded photo categories:
 * - The 4 required ones stay: LIVING_ROOM, BEDROOM, BATHROOM, KITCHEN
 * - Everything else is OPTIONAL (for cover, view, balcony, etc.)
 */
enum PropertyMediaCategory {
  // Required for review gating
  LIVING_ROOM
  BEDROOM
  BATHROOM
  KITCHEN

  // Optional but supported (vendor/admin can tag freely)
  COVER
  DINING
  ENTRY
  HALLWAY
  STUDY
  LAUNDRY

  BALCONY
  TERRACE
  VIEW
  EXTERIOR
  BUILDING
  NEIGHBORHOOD

  POOL
  GYM
  PARKING
  AMENITY

  FLOOR_PLAN
  OTHER
}

enum PropertyDocumentType {
  OWNERSHIP_PROOF
  AUTHORIZATION_PROOF
  OWNER_ID
  ADDRESS_PROOF
  HOLIDAY_HOME_PERMIT
  OTHER
}

enum PropertyDocumentStatus {
  UPLOADED
  ACCEPTED
  REJECTED
}

enum PropertyReviewDecision {
  APPROVE
  REQUEST_CHANGES
  REJECT
}

enum PropertyDeletionRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum PropertyUnpublishRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum MessageCounterpartyRole {
  VENDOR
  CUSTOMER
}

enum BookingDocumentType {
  PASSPORT
  EMIRATES_ID
  VISA
  SELFIE
  OTHER
}

enum GuestReviewStatus {
  PENDING
  APPROVED
  REJECTED
}

enum FxQuoteCurrency {
  USD
  EUR
  GBP
}

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  role         UserRole @default(CUSTOMER)

  fullName        String?
  isEmailVerified Boolean @default(false)

  vendorProfile VendorProfile?
  properties    Property[]     @relation("VendorProperties")
  bookings      Booking[]      @relation("CustomerBookings")

  holds PropertyHold[] @relation("HoldCreatedBy")

  securityDeposits SecurityDeposit[] @relation("SecurityDepositCustomer")

  vendorStatements VendorStatement[]
  payouts          Payout[]
  ledgerEntries    LedgerEntry[]

  bookingIdempotencies BookingIdempotency[]

  refreshTokens      RefreshToken[]
  emailVerifications EmailVerificationToken[]
  passwordResets     PasswordResetToken[]

  approvedVendorAgreements VendorServiceAgreement[] @relation("VendorAgreementApprovedBy")
  assignedOpsTasks         OpsTask[]                @relation("OpsTaskAssignedTo")
  createdMaintenance       MaintenanceRequest[]     @relation("MaintenanceCreatedBy")
  assignedWorkOrders       WorkOrder[]              @relation("WorkOrderAssignedTo")

  notifications NotificationEvent[] @relation("NotificationRecipient")

  // âœ… Property review relations
  propertyReviews   PropertyReview[]   @relation("PropertyReviewedByAdmin")
  uploadedDocuments PropertyDocument[] @relation("PropertyDocumentUploadedByUser")
  reviewedDocuments PropertyDocument[] @relation("PropertyDocumentReviewedByAdmin")

  // âœ… Admin-created listings audit (optional)
  createdPropertiesAsAdmin Property[] @relation("PropertyCreatedByAdmin")

  propertyDeletionRequestsAsVendor  PropertyDeletionRequest[]  @relation("PropertyDeletionRequestedByVendor")
  propertyDeletionReviewsAsAdmin    PropertyDeletionRequest[]  @relation("PropertyDeletionReviewedByAdmin")
  propertyUnpublishRequestsAsVendor PropertyUnpublishRequest[] @relation("PropertyUnpublishRequestedByVendor")
  propertyUnpublishReviewsAsAdmin   PropertyUnpublishRequest[] @relation("PropertyUnpublishReviewedByAdmin")

  adminMessageThreads        MessageThread[] @relation("MessageThreadAdmin")
  counterpartyMessageThreads MessageThread[] @relation("MessageThreadCounterparty")
  sentMessages               Message[]       @relation("MessageSender")

  uploadedBookingDocuments BookingDocument[] @relation("BookingDocumentUploadedByUser")

  guestReviews          GuestReview[] @relation("GuestReviewCustomer")
  moderatedGuestReviews GuestReview[] @relation("GuestReviewModeratedByAdmin")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([role])
  @@index([createdAt])
}

model RefreshToken {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  tokenHash    String
  replacedById String?
  revokedAt    DateTime?
  expiresAt    DateTime

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
}

model EmailVerificationToken {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  email   String
  otpHash String

  expiresAt DateTime
  usedAt    DateTime?

  attemptCount Int @default(0)

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([email])
  @@index([expiresAt])
  @@index([userId, email, usedAt])
}

model PasswordResetToken {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
}

model VendorProfile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  displayName String
  companyName String?
  phone       String?
  status      VendorStatus @default(PENDING)

  serviceAgreements VendorServiceAgreement[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
}

model Location {
  id String @id @default(uuid())

  country String
  city    String
  area    String?
  name    String?
  address String?

  lat Float?
  lng Float?

  properties Property[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([country, city])
  @@index([city, area])
}

//
// âœ… NEW: Amenity grouping (Frank Porterâ€“style)
//

model AmenityGroup {
  id        String  @id @default(uuid())
  key       String  @unique // e.g. "ESSENTIALS", "KITCHEN", "SAFETY"
  name      String
  sortOrder Int     @default(0)
  isActive  Boolean @default(true)

  amenities Amenity[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isActive])
  @@index([sortOrder])
}

model Amenity {
  id   String  @id @default(uuid())
  key  String  @unique
  name String
  icon String?

  // âœ… NEW (nullable for safe migration): group support
  groupId String?
  group   AmenityGroup? @relation(fields: [groupId], references: [id], onDelete: SetNull)

  // âœ… NEW: stable ordering + soft disable (never delete catalog rows)
  sortOrder Int     @default(0)
  isActive  Boolean @default(true)

  properties PropertyAmenity[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isActive])
  @@index([groupId])
  @@index([sortOrder])
}

model PropertyAmenity {
  propertyId String
  amenityId  String

  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  amenity  Amenity  @relation(fields: [amenityId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@id([propertyId, amenityId])
  @@index([amenityId])
}

model Property {
  id       String @id @default(uuid())
  vendorId String
  vendor   User   @relation("VendorProperties", fields: [vendorId], references: [id], onDelete: Cascade)

  // âœ… Admin-created audit (optional). If present, listing skipped vendor review.
  createdByAdminId String?
  createdByAdmin   User?   @relation("PropertyCreatedByAdmin", fields: [createdByAdminId], references: [id], onDelete: SetNull)

  title       String
  slug        String  @unique
  description String?

  city    String
  area    String?
  address String?
  lat     Float?
  lng     Float?

  locationId String?
  location   Location? @relation(fields: [locationId], references: [id], onDelete: SetNull)

  maxGuests Int @default(2)
  bedrooms  Int @default(1)
  bathrooms Int @default(1)

  basePrice   Int
  cleaningFee Int    @default(0)
  currency    String @default("AED")

  minNights      Int     @default(1)
  maxNights      Int?
  checkInFromMin Int?
  checkInToMax   Int?
  checkOutMin    Int?
  isInstantBook  Boolean @default(false)

  status PropertyStatus @default(DRAFT)

  media             Media[]
  documents         PropertyDocument[]
  reviews           PropertyReview[]
  deletionRequests  PropertyDeletionRequest[]
  unpublishRequests PropertyUnpublishRequest[]
  guestReviews      GuestReview[]

  amenities PropertyAmenity[]
  bookings  Booking[]

  availabilitySettings PropertyAvailabilitySettings?
  calendarDays         PropertyCalendarDay[]
  holds                PropertyHold[]

  securityDepositPolicy SecurityDepositPolicy?

  securityDeposits SecurityDeposit[] @relation("SecurityDepositProperty")
  ledgerEntries    LedgerEntry[]     @relation("LedgerEntryProperty")

  serviceConfig PropertyServiceConfig?
  opsTasks      OpsTask[]
  maintenance   MaintenanceRequest[]

  createdAt                DateTime                  @default(now())
  updatedAt                DateTime                  @updatedAt
  cancellationPolicyConfig CancellationPolicyConfig?

  @@index([vendorId])
  @@index([createdByAdminId])
  @@index([city])
  @@index([status])
  @@index([createdAt])
  @@index([locationId])
  @@index([city, area])
  @@index([basePrice])
  @@index([bedrooms, bathrooms, maxGuests])
  // âœ… Search performance indexes (NEW)
  @@index([status, city, area], map: "idx_property_status_city_area")
  @@index([status, lat, lng], map: "idx_property_status_lat_lng")
}

model Media {
  id         String   @id @default(uuid())
  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  url       String
  alt       String?
  sortOrder Int     @default(0)

  // âœ… NEW: photo categorization
  category PropertyMediaCategory @default(OTHER)

  createdAt DateTime @default(now())

  @@index([propertyId])
  @@index([sortOrder])
  @@index([propertyId, category])
}

model PropertyDocument {
  id         String   @id @default(uuid())
  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  type PropertyDocumentType

  // âœ… uploader (vendor user)
  uploadedByUserId String
  uploadedByUser   User   @relation("PropertyDocumentUploadedByUser", fields: [uploadedByUserId], references: [id])

  // âœ… reviewer (admin) â€” optional until reviewed
  reviewedByAdminId String?
  reviewedByAdmin   User?   @relation("PropertyDocumentReviewedByAdmin", fields: [reviewedByAdminId], references: [id], onDelete: SetNull)

  /**
   * url is now an authenticated download endpoint (NOT a public /uploads path).
   * This keeps frontend/backoffice simple: the API response can be used directly.
   */
  url String?

  /**
   * âœ… Storage fields (production safety)
   * - storageKey is the filename on disk (uuid.ext)
   * - originalName is for UX
   * - mimeType helps set correct headers
   */
  storageKey   String?
  originalName String?
  mimeType     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([propertyId])
  @@index([uploadedByUserId])
  @@index([reviewedByAdminId])
}

model PropertyReview {
  id String @id @default(uuid())

  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  adminId String
  admin   User   @relation("PropertyReviewedByAdmin", fields: [adminId], references: [id], onDelete: Cascade)

  decision PropertyReviewDecision
  notes    String?

  // Optional structured feedback (e.g., missing categories/docs)
  checklistJson String?

  createdAt DateTime @default(now())

  @@index([propertyId])
  @@index([adminId])
  @@index([decision])
  @@index([createdAt])
}

model PropertyDeletionRequest {
  id String @id @default(uuid())

  propertyId String?
  property   Property? @relation(fields: [propertyId], references: [id], onDelete: SetNull)

  propertyTitleSnapshot String
  propertyCitySnapshot  String?

  requestedByVendorId String
  requestedByVendor   User   @relation("PropertyDeletionRequestedByVendor", fields: [requestedByVendorId], references: [id], onDelete: Cascade)

  status PropertyDeletionRequestStatus @default(PENDING)
  reason String?

  reviewedByAdminId String?
  reviewedByAdmin   User?     @relation("PropertyDeletionReviewedByAdmin", fields: [reviewedByAdminId], references: [id], onDelete: SetNull)
  reviewedAt        DateTime?
  adminNotes        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([propertyId])
  @@index([requestedByVendorId])
  @@index([status])
  @@index([createdAt])
}

model PropertyUnpublishRequest {
  id String @id @default(uuid())

  propertyId String?
  property   Property? @relation(fields: [propertyId], references: [id], onDelete: SetNull)

  propertyTitleSnapshot String
  propertyCitySnapshot  String?

  requestedByVendorId String
  requestedByVendor   User   @relation("PropertyUnpublishRequestedByVendor", fields: [requestedByVendorId], references: [id], onDelete: Cascade)

  status PropertyUnpublishRequestStatus @default(PENDING)
  reason String?

  reviewedByAdminId String?
  reviewedByAdmin   User?     @relation("PropertyUnpublishReviewedByAdmin", fields: [reviewedByAdminId], references: [id], onDelete: SetNull)
  reviewedAt        DateTime?
  adminNotes        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([propertyId])
  @@index([requestedByVendorId])
  @@index([status])
  @@index([createdAt])
}

model MessageThread {
  id String @id @default(uuid())

  adminId String
  admin   User   @relation("MessageThreadAdmin", fields: [adminId], references: [id], onDelete: Cascade)

  counterpartyUserId String
  counterpartyUser   User                    @relation("MessageThreadCounterparty", fields: [counterpartyUserId], references: [id], onDelete: Cascade)
  counterpartyRole   MessageCounterpartyRole

  subject String?

  lastMessageAt          DateTime?
  lastMessagePreview     String?
  lastMessageSenderId    String?
  adminLastReadAt        DateTime?
  counterpartyLastReadAt DateTime?

  messages Message[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([adminId, counterpartyUserId], map: "uniq_message_thread_admin_counterparty")
  @@index([counterpartyUserId, counterpartyRole])
  @@index([lastMessageAt])
}

model Message {
  id String @id @default(cuid())

  threadId String
  thread   MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  senderId String
  sender   User   @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  body String

  createdAt DateTime @default(now())

  @@index([threadId, createdAt])
  @@index([senderId])
}

model BookingDocument {
  id String @id @default(uuid())

  bookingId String
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  uploadedByUserId String
  uploadedByUser   User   @relation("BookingDocumentUploadedByUser", fields: [uploadedByUserId], references: [id], onDelete: Cascade)

  type BookingDocumentType @default(OTHER)

  storageKey   String
  originalName String?
  mimeType     String?
  notes        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bookingId])
  @@index([uploadedByUserId])
  @@index([type])
}

model GuestReview {
  id String @id @default(uuid())

  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  bookingId String  @unique
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  customerId String
  customer   User   @relation("GuestReviewCustomer", fields: [customerId], references: [id], onDelete: Cascade)

  rating  Int
  title   String?
  comment String?

  status GuestReviewStatus @default(PENDING)

  moderatedByAdminId String?
  moderatedByAdmin   User?     @relation("GuestReviewModeratedByAdmin", fields: [moderatedByAdminId], references: [id], onDelete: SetNull)
  moderatedAt        DateTime?
  moderationNotes    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([propertyId, status])
  @@index([customerId, createdAt])
}

model FxRate {
  id String @id @default(cuid())

  baseCurrency  String          @default("AED")
  quoteCurrency FxQuoteCurrency
  rate          Decimal         @db.Decimal(18, 8)
  asOfDate      DateTime
  updatedAt     DateTime        @updatedAt

  @@unique([baseCurrency, quoteCurrency, asOfDate], map: "uniq_fx_rate_base_quote_date")
  @@index([asOfDate])
}

model Booking {
  id String @id @default(uuid())

  customerId String
  customer   User   @relation("CustomerBookings", fields: [customerId], references: [id], onDelete: Cascade)

  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  holdId String       @unique
  hold   PropertyHold @relation(fields: [holdId], references: [id], onDelete: Restrict)

  checkIn  DateTime
  checkOut DateTime

  adults   Int @default(1)
  children Int @default(0)

  status BookingStatus @default(PENDING_PAYMENT)

  totalAmount Int
  currency    String @default("AED")

  idempotencyKey     String?
  idempotencyRecords BookingIdempotency[]

  payment Payment?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  expiresAt   DateTime?
  cancelledAt DateTime?

  cancellation BookingCancellation?

  cancelledBy        CancellationActor?
  cancellationReason CancellationReason?

  securityDeposit SecurityDeposit?

  ledgerEntries LedgerEntry[] @relation("LedgerEntryBooking")

  refunds     Refund[]
  documents   BookingDocument[]
  guestReview GuestReview?

  opsTasks    OpsTask[]
  maintenance MaintenanceRequest[]

  @@unique([customerId, idempotencyKey], map: "uniq_booking_idempotency_per_customer")
  @@index([customerId])
  @@index([propertyId])
  @@index([status])
  @@index([checkIn, checkOut])
  // âœ… Availability-search overlap index (NEW)
  @@index([propertyId, status, checkIn, checkOut], map: "idx_booking_property_status_dates")
}

model BookingIdempotency {
  id             String  @id @default(cuid())
  userId         String
  user           User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  idempotencyKey String
  bookingId      String  @unique
  booking        Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, idempotencyKey])
  @@index([createdAt])
}

model Payment {
  id        String  @id @default(uuid())
  bookingId String  @unique
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  provider PaymentProvider @default(MANUAL)
  status   PaymentStatus   @default(REQUIRES_ACTION)

  amount   Int
  currency String @default("AED")

  providerRef String?

  ledgerEntries LedgerEntry[] @relation("LedgerEntryPayment")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  refunds   Refund[]

  events PaymentEvent[]

  @@index([status])
  @@index([provider])
}

model PropertyAvailabilitySettings {
  id                String   @id @default(cuid())
  propertyId        String   @unique
  defaultMinNights  Int      @default(1)
  defaultMaxNights  Int?
  advanceNoticeDays Int      @default(0)
  preparationDays   Int      @default(0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@index([propertyId])
}

model PropertyCalendarDay {
  id                String            @id @default(cuid())
  propertyId        String
  date              DateTime
  status            CalendarDayStatus @default(AVAILABLE)
  minNightsOverride Int?
  note              String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@unique([propertyId, date])
  @@index([propertyId, date])
  // âœ… Availability-search index (NEW): quickly find BLOCKED days in a date range
  @@index([propertyId, status, date], map: "idx_calendar_property_status_date")
}

model PropertyHold {
  id         String     @id @default(cuid())
  propertyId String
  checkIn    DateTime
  checkOut   DateTime
  status     HoldStatus @default(ACTIVE)
  expiresAt  DateTime

  createdById String
  createdBy   User   @relation("HoldCreatedBy", fields: [createdById], references: [id], onDelete: Cascade)

  bookingId   String?   @unique
  booking     Booking?
  convertedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@index([propertyId, status, expiresAt])
  @@index([propertyId, checkIn, checkOut])
  @@index([createdById])
  // âœ… Availability-search overlap index (NEW)
  @@index([propertyId, status, checkIn, checkOut, expiresAt], map: "idx_hold_property_status_dates_expires")
}

model PaymentEvent {
  id String @id @default(cuid())

  paymentId String
  payment   Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  type PaymentEventType

  idempotencyKey String?
  providerRef    String?
  payloadJson    String?

  createdAt DateTime @default(now())

  @@unique([paymentId, type, idempotencyKey], name: "uniq_payment_event_idempotency", map: "uniq_payment_event_idempotency")
  @@index([paymentId])
  @@index([type])
  @@index([createdAt])
}

model BookingCancellation {
  id String @id @default(cuid())

  bookingId String  @unique
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  actor  CancellationActor
  reason CancellationReason
  notes  String?
  mode   CancellationMode   @default(SOFT)

  policyVersion String?

  cancelledAt DateTime @default(now())

  totalAmount      Int
  managementFee    Int    @default(0)
  penaltyAmount    Int    @default(0)
  refundableAmount Int    @default(0)
  currency         String @default("AED")

  releasesInventory Boolean @default(true)

  refundId String? @unique
  refund   Refund? @relation(fields: [refundId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([cancelledAt])
  @@index([actor])
  @@index([reason])
}

model CancellationPolicyConfig {
  id String @id @default(cuid())

  propertyId String?   @unique
  property   Property? @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  version  String
  isActive Boolean @default(true)

  freeCancelBeforeHours    Int @default(0)
  partialRefundBeforeHours Int @default(0)
  noRefundWithinHours      Int @default(0)

  penaltyType  PenaltyType @default(PERCENT_OF_TOTAL)
  penaltyValue Int         @default(0)

  defaultMode CancellationMode @default(SOFT)

  chargeFirstNightOnLateCancel Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isActive])
  @@index([version])
}

model Refund {
  id String @id @default(uuid())

  bookingId String
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  paymentId String?
  payment   Payment? @relation(fields: [paymentId], references: [id], onDelete: SetNull)

  status RefundStatus @default(PENDING)
  reason RefundReason @default(CANCELLATION)

  amount   Int
  currency String @default("AED")

  ledgerEntries LedgerEntry[] @relation("LedgerEntryRefund")

  provider          PaymentProvider @default(MANUAL)
  providerRefundRef String?

  idempotencyKey String?

  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  bookingCancellation BookingCancellation?

  @@index([status])
  @@index([provider])
  @@index([bookingId])
}

model SecurityDepositPolicy {
  id String @id @default(uuid())

  propertyId String   @unique
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  mode     SecurityDepositMode @default(NONE)
  amount   Int                 @default(0)
  currency String              @default("AED")

  // How long after checkout we keep the deposit before auto-release (if you later add automation)
  holdDaysAfterCheckout Int @default(0)

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([propertyId])
  @@index([isActive])
}

model SecurityDeposit {
  id String @id @default(uuid())

  bookingId String  @unique
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  propertyId String
  property   Property @relation("SecurityDepositProperty", fields: [propertyId], references: [id], onDelete: Cascade)

  customerId String
  customer   User   @relation("SecurityDepositCustomer", fields: [customerId], references: [id], onDelete: Cascade)

  mode   SecurityDepositMode
  status SecurityDepositStatus @default(REQUIRED)

  amount   Int
  currency String @default("AED")

  provider    PaymentProvider @default(MANUAL)
  providerRef String?

  authorizedAt DateTime?
  capturedAt   DateTime?
  releasedAt   DateTime?
  claimedAt    DateTime?
  cancelledAt  DateTime?

  note     String?
  metaJson String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bookingId])
  @@index([propertyId])
  @@index([customerId])
  @@index([status])
}

model VendorStatement {
  id String @id @default(uuid())

  vendorId String
  vendor   User   @relation(fields: [vendorId], references: [id], onDelete: Cascade)

  periodStart DateTime
  periodEnd   DateTime

  currency String @default("AED")

  status VendorStatementStatus @default(DRAFT)

  // Snapshot totals (immutably stored once finalized)
  grossBookings  Int @default(0)
  managementFees Int @default(0)
  refunds        Int @default(0)
  adjustments    Int @default(0)
  netPayable     Int @default(0)

  generatedAt DateTime  @default(now())
  finalizedAt DateTime?
  paidAt      DateTime?

  metaJson String?

  ledgerEntries LedgerEntry[]
  payout        Payout?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([vendorId, periodStart, periodEnd], map: "uniq_vendor_statement_period")
  @@index([vendorId])
  @@index([status])
  @@index([periodStart, periodEnd])
}

model Payout {
  id String @id @default(uuid())

  vendorId String
  vendor   User   @relation(fields: [vendorId], references: [id], onDelete: Cascade)

  statementId String          @unique
  statement   VendorStatement @relation(fields: [statementId], references: [id], onDelete: Cascade)

  status PayoutStatus @default(PENDING)

  amount   Int
  currency String @default("AED")

  provider    PaymentProvider @default(MANUAL)
  providerRef String?

  scheduledAt   DateTime?
  processedAt   DateTime?
  failedAt      DateTime?
  failureReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([vendorId])
  @@index([status])
  @@index([provider])
}

model LedgerEntry {
  id String @id @default(cuid())

  vendorId String
  vendor   User   @relation(fields: [vendorId], references: [id], onDelete: Cascade)

  propertyId String?
  property   Property? @relation("LedgerEntryProperty", fields: [propertyId], references: [id], onDelete: SetNull)

  bookingId String?
  booking   Booking? @relation("LedgerEntryBooking", fields: [bookingId], references: [id], onDelete: SetNull)

  paymentId String?
  payment   Payment? @relation("LedgerEntryPayment", fields: [paymentId], references: [id], onDelete: SetNull)

  refundId String?
  refund   Refund? @relation("LedgerEntryRefund", fields: [refundId], references: [id], onDelete: SetNull)

  statementId String?
  statement   VendorStatement? @relation(fields: [statementId], references: [id], onDelete: SetNull)

  type      LedgerEntryType
  direction LedgerDirection

  amount   Int
  currency String @default("AED")

  occurredAt DateTime @default(now())

  // idempotencyKey lets us safely re-run hooks (webhook retries, etc.)
  idempotencyKey String?

  metaJson String?

  createdAt DateTime @default(now())

  @@unique([vendorId, type, idempotencyKey], map: "uniq_ledger_idempotency")
  @@index([vendorId])
  @@index([type])
  @@index([occurredAt])
  @@index([statementId])
  @@index([bookingId])
  @@index([paymentId])
}

model NotificationEvent {
  id String @id @default(cuid())

  type    NotificationType
  channel NotificationChannel @default(EMAIL)
  status  NotificationStatus  @default(PENDING)

  entityType String
  entityId   String

  recipientUserId String
  recipientUser   User   @relation("NotificationRecipient", fields: [recipientUserId], references: [id], onDelete: Cascade)

  payloadJson String

  attempts      Int      @default(0)
  lastError     String?
  nextAttemptAt DateTime @default(now())

  createdAt DateTime  @default(now())
  sentAt    DateTime?

  @@unique([type, channel, entityType, entityId, recipientUserId], map: "uniq_notification_idempotency")
  @@index([type])
  @@index([status])
  @@index([status, nextAttemptAt])
  @@index([recipientUserId])
  @@index([entityType, entityId])
}

model ServicePlan {
  id String @id @default(uuid())

  type ServicePlanType
  code String          @unique

  name        String
  description String?

  managementFeeBps Int

  includesCleaning    Boolean @default(false)
  includesLinen       Boolean @default(false)
  includesInspection  Boolean @default(false)
  includesRestock     Boolean @default(false)
  includesMaintenance Boolean @default(false)

  isActive Boolean @default(true)

  agreements      VendorServiceAgreement[]
  propertyConfigs PropertyServiceConfig[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
  @@index([isActive])
}

model VendorServiceAgreement {
  id String @id @default(uuid())

  vendorProfileId String
  vendorProfile   VendorProfile @relation(fields: [vendorProfileId], references: [id], onDelete: Cascade)

  servicePlanId String
  servicePlan   ServicePlan @relation(fields: [servicePlanId], references: [id], onDelete: Restrict)

  status VendorAgreementStatus @default(ACTIVE)

  startDate DateTime  @default(now())
  endDate   DateTime?

  agreedManagementFeeBps Int

  notes String?

  approvedByAdminId String?
  approvedByAdmin   User?     @relation("VendorAgreementApprovedBy", fields: [approvedByAdminId], references: [id], onDelete: SetNull)
  approvedAt        DateTime?

  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  propertyServiceConfigs PropertyServiceConfig[]

  @@index([vendorProfileId, status, startDate])
  @@index([servicePlanId])
}

model PropertyServiceConfig {
  id String @id @default(uuid())

  propertyId String   @unique
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  servicePlanId String
  servicePlan   ServicePlan @relation(fields: [servicePlanId], references: [id], onDelete: Restrict)

  vendorAgreementId String?
  vendorAgreement   VendorServiceAgreement? @relation(fields: [vendorAgreementId], references: [id], onDelete: SetNull)

  cleaningRequired    Boolean?
  linenChangeRequired Boolean?
  inspectionRequired  Boolean?
  restockRequired     Boolean?
  maintenanceIncluded Boolean?

  guestCleaningFee Int?
  linenFee         Int?
  inspectionFee    Int?
  restockFee       Int?

  currency String @default("AED")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([servicePlanId])
  @@index([vendorAgreementId])
}

model OpsTask {
  id String @id @default(uuid())

  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  type   OpsTaskType
  status OpsTaskStatus @default(PENDING)

  scheduledFor DateTime
  dueAt        DateTime?

  assignedToUserId String?
  assignedToUser   User?   @relation("OpsTaskAssignedTo", fields: [assignedToUserId], references: [id], onDelete: SetNull)

  checklistJson String?
  notes         String?

  completedAt DateTime?
  cancelledAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([bookingId, type], map: "uniq_ops_task_per_booking_type")
  @@index([propertyId, status, scheduledFor])
  @@index([bookingId])
  @@index([assignedToUserId])
}

model MaintenanceRequest {
  id String @id @default(uuid())

  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: SetNull)

  createdByUserId String?
  createdByUser   User?   @relation("MaintenanceCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)

  title       String
  description String?

  priority MaintenancePriority @default(MEDIUM)
  status   MaintenanceStatus   @default(OPEN)

  metaJson String?

  workOrders WorkOrder[]

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  resolvedAt DateTime?

  @@index([propertyId, status])
  @@index([priority])
  @@index([bookingId])
  @@index([createdByUserId])
}

model WorkOrder {
  id String @id @default(uuid())

  maintenanceRequestId String
  maintenanceRequest   MaintenanceRequest @relation(fields: [maintenanceRequestId], references: [id], onDelete: Cascade)

  status WorkOrderStatus @default(DRAFT)

  assignedToUserId String?
  assignedToUser   User?   @relation("WorkOrderAssignedTo", fields: [assignedToUserId], references: [id], onDelete: SetNull)

  costEstimate Int?
  actualCost   Int?
  currency     String @default("AED")

  notes String?

  startedAt   DateTime?
  completedAt DateTime?
  cancelledAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([maintenanceRequestId])
  @@index([status])
  @@index([assignedToUserId])
}
